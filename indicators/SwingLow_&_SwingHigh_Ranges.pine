// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ACCESS ALGO â€“ Project 19 -FxPro Walkforward
// Â© Hc_Sunt_Lucrum | access-algo.com
// This script is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
//
// Description: Project 19.5 experiments with fixed closed paramters. Such as next green candle close.
// 
//
// Usage: Private
// Designed for TradingView. Compatible with Pine Script v6.
// Free to use under invite-only rules or for educational purposes.
//
// Version:         v16
// Last Updated:    2025-07-17
// Author:          Hc_Sunt_Lucrum
// Contact:         access-algo.com | TradingView: @Hc_Sunt_Lucrum
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


//strategy("Client Build 117 - DAX Reversals ", overlay=true, default_qty_type=strategy.percent_of_equity, initial_capital=100000, currency=currency.USD,calc_on_order_fills = true)

// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Hc_Sunt_Lucrum

//@version=6
indicator('Swing High Low Detector with Entry bars', overlay = true, max_lines_count = 500)

// Import Zen if not already present in this file:
import ZenAndTheArtOfTrading/ZenLibrary/10 as zen

// Time/Date/Session =====================================================//
//  { Date window (keep as-is)
var const string title_and_next = "=============== Backtest Time Periods ==============="
fromDay   = input.int(1,  "D", minval = 1, maxval = 31, inline="1", group=title_and_next)
fromMonth = input.int(1,  "M", minval = 1, maxval = 12, inline="1", group=title_and_next)
fromYear  = input.int(2010, "Y", minval = 1970, inline="1", group=title_and_next)
toDay     = input.int(31, "D", minval = 1, maxval = 31, inline="2", group=title_and_next)
toMonth   = input.int(12, "M", minval = 1, maxval = 12, inline="2", group=title_and_next)
toYear    = input.int(2099, "Y", minval = 1970, inline="2", group=title_and_next)

startDate  = timestamp(fromYear, fromMonth, fromDay, 00, 00)
finishDate = timestamp(toYear,   toMonth,   toDay,   23, 59)
date_cond  = (time >= startDate and time <= finishDate)

var const string day_of_week = "--- Trading Days ---"
is_trade_mon = input.bool(true,  "Mon", inline="dow", group=day_of_week)
is_trade_tue = input.bool(true,  "Tue", inline="dow", group=day_of_week)
is_trade_wed = input.bool(true,  "Wed", inline="dow", group=day_of_week)
is_trade_thu = input.bool(true,  "Thu", inline="dow", group=day_of_week)
is_trade_fri = input.bool(true,  "Fri", inline="dow", group=day_of_week)
is_trade_sat = input.bool(true,  "Sat", inline="dow", group=day_of_week)
is_trade_sun = input.bool(true,  "Sun", inline="dow", group=day_of_week)

day_cond =
     (dayofweek(time) == dayofweek.monday    and is_trade_mon) or
     (dayofweek(time) == dayofweek.tuesday   and is_trade_tue) or
     (dayofweek(time) == dayofweek.wednesday and is_trade_wed) or
     (dayofweek(time) == dayofweek.thursday  and is_trade_thu) or
     (dayofweek(time) == dayofweek.friday    and is_trade_fri) or
     (dayofweek(time) == dayofweek.saturday  and is_trade_sat) or
     (dayofweek(time) == dayofweek.sunday    and is_trade_sun)

// Timezone
UTC_offset = input.int(defval = 0, title='UTC Offset', tooltip = "Plus or minus hours of chart time", minval=-10, maxval=13, group=day_of_week)
UTC_string = 'UTC' + (UTC_offset > 0 ? '+' : '') + (UTC_offset != 0 ? str.tostring(UTC_offset) : '')

// TWO sessions â€“ defaults from scope: 08:00â€“11:30 and 14:00â€“17:00 CET
sess1 = input.session("0800-1130", "Session 1 (AM)", group='--- Trading Sessions ---')
sess2 = input.session("1400-1700", "Session 2 (PM)", group='--- Trading Sessions ---')

// Per-session time checks
time_cond_1 = time(timeframe.period, sess1, UTC_string)
time_cond_2 = time(timeframe.period, sess2, UTC_string)

// Combined session condition
session_cond = (not na(time_cond_1)) or (not na(time_cond_2))

// Final condition
final_time_cond = date_cond and day_cond and session_cond

// Visual: show which session we're in
bgcolor(not na(time_cond_1) and day_cond and date_cond ? color.new(color.green, 90) : not na(time_cond_2) and day_cond and date_cond ? color.new(color.blue,  90) : na)

// This is what you'll use later to gate entries:
isinSession = final_time_cond

// }


// === INPUTS FOR SH/SL DETECTION ===
// {
var const string doubleBottom = "========== Double Bottom Detection Settings =========="
swingStrengthHigh = input.int(5, minval = 1, title = 'Swing high Lookback', tooltip = "How many candles to look back and determine and local Swing High upon which to trigger a doubble bottom search", display = display.all - display.status_line, group = doubleBottom)
swingStrengthLow = input.int(5, minval = 1, title = 'Swing low Lookback', tooltip = "How many candles to look back and determine and local Swing Low upon which to trigger a doubble bottom search", display = display.all - display.status_line, group = doubleBottom)
swingSourceHigh = input.source(high, title = 'Swing high source', display = display.all - display.status_line, group = doubleBottom)
swingSourceLow = input.source(low, title = 'Swing low source', display = display.all - display.status_line, group = doubleBottom)
sweepConditionOpt = input.string("Close Break", title = "Sweep condition type", options = ["Wick Break", "Close Break"], tooltip = "Choose whether swing levels are deleted when price wicks through them (high/low) or closes through them (close).", group = doubleBottom)
extendAfterBreakBars = input.int(2, "Extend zones N bars after invalidation", minval=0, tooltip="Keeps the swing line and its ATR band visible for N bars after the level is broken.",group = doubleBottom)
doubeBottomATRLength = input.int(14, title = "Double Bottom ATR length", group = doubleBottom)
doubleBottomATRBand = input.float(1, title = "Double Bottom Zone ATR Multiplier", tooltip = "Creates a band around a local Swing High or Swing Low, upon which to detect the presence of a reversal candle and confirm and double bottom entry. Number multiplies the Double Bottom ATR",group = doubleBottom)
removeSweptLevels = input.bool(false, title = 'Delete swept double bottoms', tooltip = 'When enabled, past swing lines will be deleted if price closes through them.', group = doubleBottom)
// } 

//===VISUAL SETTINGS FOR BANDS===
// {
shColor = input.color(color.red, 'Swing High Colour', group = '--- Visuals ---', display = display.all - display.status_line)
slColor = input.color(color.aqua, 'Swing Low Colour', group = '--- Visuals ---', display = display.all - display.status_line)
bandColor = input.color(color.white, 'ATR Band Colour', group = '--- Visuals ---', display = display.all - display.status_line)
width = input.int(1, 'Line Thickness', minval = 1, maxval = 5, group = '--- Visuals ---', display = display.all - display.status_line)
styleStr = input.string('Dotted', 'Style', options = ['Solid', 'Dotted', 'Dashed'], group = '--- Visuals ---', display = display.all - display.status_line)
style = styleStr == 'Dotted' ? line.style_dotted : styleStr == 'Dashed' ? line.style_dashed : line.style_solid
// }

//ATR BAND VARIABLE
dbRangeAtr = (ta.atr(doubeBottomATRLength) * doubleBottomATRBand) / 2


// === VARS ===
var line currentHighLine = na
var line currentLowLine = na
var float currentHigh = na
var float currentLow = na
var int currentHighStart = na
var int currentLowStart = na
var array<line> pastHighLines = array.new_line()
var array<float> pastHighPrices = array.new_float()
var array<line> pastLowLines = array.new_line()
var array<float> pastLowPrices = array.new_float()

// Current bands
var line currentHighBandTopLine = na
var line currentHighBandBotLine = na
var line currentLowBandTopLine  = na
var line currentLowBandBotLine  = na
var float currentHighBandHalf = na
var float currentLowBandHalf  = na

// Past band arrays (parallel to your pastHigh/Low arrays)
var array<line> pastHighBandTopLines = array.new_line()
var array<line> pastHighBandBotLines = array.new_line()
var array<line> pastLowBandTopLines  = array.new_line()
var array<line> pastLowBandBotLines  = array.new_line()

// Post-break extension handles (HIGH side)
var line extHighBaseLine = na
var line extHighBandTopLine = na
var line extHighBandBotLine = na
var int extHighBarsLeft = 0
var float extHighPrice = na
var float extHighBandHalf = na


// Post-break extension handles (LOW side)
var line extLowBaseLine = na
var line extLowBandTopLine = na
var line extLowBandBotLine = na
var int extLowBarsLeft = 0
var float extLowPrice = na
var float extLowBandHalf = na


useCloseForSweep = sweepConditionOpt == "Close Break"


// === SWING LOGIC ===
isSwingHigh = true
for i = 1 to swingStrengthHigh by 1
    isSwingHigh := isSwingHigh and swingSourceHigh[swingStrengthHigh] > swingSourceHigh[swingStrengthHigh + i]
    isSwingHigh := isSwingHigh and swingSourceHigh[swingStrengthHigh] > swingSourceHigh[swingStrengthHigh - i]
    isSwingHigh
swingHigh = isSwingHigh ? swingSourceHigh[swingStrengthHigh] : na

isSwingLow = true
for i = 1 to swingStrengthLow by 1
    isSwingLow := isSwingLow and swingSourceLow[swingStrengthLow] < swingSourceLow[swingStrengthLow + i]
    isSwingLow := isSwingLow and swingSourceLow[swingStrengthLow] < swingSourceLow[swingStrengthLow - i]
    isSwingLow
swingLow = isSwingLow ? swingSourceLow[swingStrengthLow] : na

// === BREAK CONDITIONS ===
highBroken = not na(currentHigh) and high > currentHigh
lowBroken = not na(currentLow) and low < currentLow

// === HANDLE SWING HIGH ===
if not na(swingHigh)
    if not na(currentHighLine)
        line.set_extend(currentHighLine, extend.none)
        line.set_style(currentHighLine, style)
        array.push(pastHighLines, line.new(currentHighStart, currentHigh, bar_index, currentHigh, color = shColor, width = width, style = style, extend = extend.none))
        array.push(pastHighPrices, currentHigh)
        line.delete(currentHighLine)

        // Archive CURRENT HIGH bands to PAST (if they exist)
        if not na(currentHighBandTopLine) and not na(currentHighBandBotLine)
            array.push(pastHighBandTopLines, line.new(currentHighStart, currentHigh + currentHighBandHalf, bar_index, currentHigh + currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
            array.push(pastHighBandBotLines, line.new(currentHighStart, currentHigh - currentHighBandHalf, bar_index, currentHigh - currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
            line.delete(currentHighBandTopLine)
            line.delete(currentHighBandBotLine)
            currentHighBandTopLine := na
            currentHighBandBotLine := na
            currentHighBandHalf    := na
   
    currentHigh := swingHigh
    currentHighStart := bar_index - swingStrengthHigh
    currentHighLine := line.new(currentHighStart, swingHigh, bar_index, swingHigh, color = shColor, width = width, style = style, extend = extend.none)
    currentHighBandHalf := dbRangeAtr
    currentHighBandTopLine := line.new(currentHighStart, currentHigh + currentHighBandHalf, bar_index, currentHigh + currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
    currentHighBandBotLine := line.new(currentHighStart, currentHigh - currentHighBandHalf, bar_index, currentHigh - currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
    currentHighLine





// === HANDLE SWING LOW ===
if not na(swingLow)
    if not na(currentLowLine)
        line.set_extend(currentLowLine, extend.none)
        line.set_style(currentLowLine, style)
        array.push(pastLowLines, line.new(currentLowStart, currentLow, bar_index, currentLow, color = slColor, width = width, style = style, extend = extend.none))
        array.push(pastLowPrices, currentLow)
        line.delete(currentLowLine)

        // Archive CURRENT LOW bands to PAST (if they exist)
        if not na(currentLowBandTopLine) and not na(currentLowBandBotLine)
            array.push(pastLowBandTopLines, line.new(currentLowStart, currentLow + currentLowBandHalf, bar_index, currentLow + currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
            array.push(pastLowBandBotLines, line.new(currentLowStart, currentLow - currentLowBandHalf, bar_index, currentLow - currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
            line.delete(currentLowBandTopLine)
            line.delete(currentLowBandBotLine)
            currentLowBandTopLine := na
            currentLowBandBotLine := na
            currentLowBandHalf    := na

    currentLow := swingLow
    currentLowStart := bar_index - swingStrengthLow
    currentLowLine := line.new(currentLowStart, swingLow, bar_index, swingLow, color = slColor, width = width, style = style, extend = extend.none)
    currentLowBandHalf    := dbRangeAtr
    currentLowBandTopLine := line.new(currentLowStart, currentLow + currentLowBandHalf, bar_index, currentLow + currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
    currentLowBandBotLine := line.new(currentLowStart, currentLow - currentLowBandHalf, bar_index, currentLow - currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
    currentLowLine

// === EXTEND CURRENT LINES TO CURRENT BAR ===
if not na(currentHighLine)
    line.set_x2(currentHighLine, bar_index)
    line.set_y2(currentHighLine, currentHigh)

if not na(currentLowLine)
    line.set_x2(currentLowLine, bar_index)
    line.set_y2(currentLowLine, currentLow)

// Extend HIGH bands
if not na(currentHighBandTopLine)
    line.set_x2(currentHighBandTopLine, bar_index)
    line.set_y2(currentHighBandTopLine, currentHigh + currentHighBandHalf)
if not na(currentHighBandBotLine)
    line.set_x2(currentHighBandBotLine, bar_index)
    line.set_y2(currentHighBandBotLine, currentHigh - currentHighBandHalf)

// Extend LOW bands
if not na(currentLowBandTopLine)
    line.set_x2(currentLowBandTopLine, bar_index)
    line.set_y2(currentLowBandTopLine, currentLow + currentLowBandHalf)
if not na(currentLowBandBotLine)
    line.set_x2(currentLowBandBotLine, bar_index)
    line.set_y2(currentLowBandBotLine, currentLow - currentLowBandHalf)

// Post-break extension updater (HIGH)
if extHighBarsLeft > 0
    // extend horizontally to the current bar
    line.set_x2(extHighBaseLine, bar_index)
    line.set_x2(extHighBandTopLine, bar_index)
    line.set_x2(extHighBandBotLine, bar_index)
    // keep y fixed
    line.set_y2(extHighBaseLine,    extHighPrice)
    line.set_y2(extHighBandTopLine, extHighPrice + extHighBandHalf)
    line.set_y2(extHighBandBotLine, extHighPrice - extHighBandHalf)

    if barstate.isconfirmed
        extHighBarsLeft -= 1
        if extHighBarsLeft <= 0
            line.delete(extHighBaseLine)
            line.delete(extHighBandTopLine)
            line.delete(extHighBandBotLine)
            extHighBaseLine    := na
            extHighBandTopLine := na
            extHighBandBotLine := na
            extHighPrice       := na
            extHighBandHalf    := na

// Post-break extension updater (LOW)
if extLowBarsLeft > 0
    line.set_x2(extLowBaseLine, bar_index)
    line.set_x2(extLowBandTopLine, bar_index)
    line.set_x2(extLowBandBotLine, bar_index)
    line.set_y2(extLowBaseLine,    extLowPrice)
    line.set_y2(extLowBandTopLine, extLowPrice + extLowBandHalf)
    line.set_y2(extLowBandBotLine, extLowPrice - extLowBandHalf)

    if barstate.isconfirmed
        extLowBarsLeft -= 1
        if extLowBarsLeft <= 0
            line.delete(extLowBaseLine)
            line.delete(extLowBandTopLine)
            line.delete(extLowBandBotLine)
            extLowBaseLine    := na
            extLowBandTopLine := na
            extLowBandBotLine := na
            extLowPrice       := na
            extLowBandHalf    := na

// === HANDLE BREAKS ===
if highBroken
    // archive the current high base line to "past"
    line.set_extend(currentHighLine, extend.none)
    line.set_style(currentHighLine, style)
    array.push(pastHighLines, line.new(currentHighStart, currentHigh, bar_index, currentHigh, color = shColor, width = width, style = style, extend = extend.none))
    array.push(pastHighPrices, currentHigh)

    // archive the CURRENT HIGH bands to "past" BEFORE clearing vars
    if not na(currentHighBandTopLine) and not na(currentHighBandBotLine)
        array.push(pastHighBandTopLines, line.new(currentHighStart, currentHigh + currentHighBandHalf, bar_index, currentHigh + currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
        array.push(pastHighBandBotLines, line.new(currentHighStart, currentHigh - currentHighBandHalf, bar_index, currentHigh - currentHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
        
    // spawn post-break extension clones for N bars
    if extendAfterBreakBars > 0
        extHighPrice    := currentHigh
        extHighBandHalf := currentHighBandHalf
        extHighBaseLine    := line.new(bar_index, extHighPrice, bar_index, extHighPrice, color = shColor, width = width, style = style, extend = extend.none)
        extHighBandTopLine := line.new(bar_index, extHighPrice + extHighBandHalf, bar_index, extHighPrice + extHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
        extHighBandBotLine := line.new(bar_index, extHighPrice - extHighBandHalf, bar_index, extHighPrice - extHighBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
        extHighBarsLeft := extendAfterBreakBars

    // now clear the current high base line + vars
    line.delete(currentHighBandTopLine)
    line.delete(currentHighBandBotLine)
    currentHighBandTopLine := na
    currentHighBandBotLine := na
    currentHighBandHalf    := na
    line.delete(currentHighLine)
    currentHighLine  := na
    currentHigh      := na
    currentHighStart := na

if lowBroken
    // archive the current low base line to "past"
    line.set_extend(currentLowLine, extend.none)
    line.set_style(currentLowLine, style)
    array.push(pastLowLines, line.new(currentLowStart, currentLow, bar_index, currentLow, color = slColor, width = width, style = style, extend = extend.none))
    array.push(pastLowPrices, currentLow)

    // archive CURRENT LOW bands to "past" BEFORE clearing vars
    if not na(currentLowBandTopLine) and not na(currentLowBandBotLine)
        array.push(pastLowBandTopLines, line.new(currentLowStart, currentLow + currentLowBandHalf, bar_index, currentLow + currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
        array.push(pastLowBandBotLines, line.new(currentLowStart, currentLow - currentLowBandHalf, bar_index, currentLow - currentLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none))
   
    // spawn post-break extension clones for N bars
    if extendAfterBreakBars > 0
        extLowPrice    := currentLow
        extLowBandHalf := currentLowBandHalf
        extLowBaseLine    := line.new(bar_index, extLowPrice, bar_index, extLowPrice, color = slColor, width = width, style = style, extend = extend.none)
        extLowBandTopLine := line.new(bar_index, extLowPrice + extLowBandHalf, bar_index, extLowPrice + extLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
        extLowBandBotLine := line.new(bar_index, extLowPrice - extLowBandHalf, bar_index, extLowPrice - extLowBandHalf, color = bandColor, width = width, style = style, extend = extend.none)
        extLowBarsLeft := extendAfterBreakBars

    // now clear the current low base line + vars
    line.delete(currentLowBandTopLine)
    line.delete(currentLowBandBotLine)
    currentLowBandTopLine := na
    currentLowBandBotLine := na
    currentLowBandHalf    := na
    line.delete(currentLowLine)
    currentLowLine  := na
    currentLow      := na
    currentLowStart := na

// === REMOVE SWEPT PAST LEVELS ===
if removeSweptLevels
    // Sweep Highs
    i = array.size(pastHighPrices) - 1
    while i >= 0
        lvl = array.get(pastHighPrices, i)
        if (useCloseForSweep ? close > lvl : high > lvl)
            line.delete(array.get(pastHighLines, i))
            array.remove(pastHighLines, i)
            array.remove(pastHighPrices, i)

            // delete matching band lines at the same index (if they exist)
            if array.size(pastHighBandTopLines) > i
                line.delete(array.get(pastHighBandTopLines, i))
                array.remove(pastHighBandTopLines, i)
            if array.size(pastHighBandBotLines) > i
                line.delete(array.get(pastHighBandBotLines, i))
                array.remove(pastHighBandBotLines, i)
        i := i - 1
        i

    // Sweep Lows
    j = array.size(pastLowPrices) - 1
    while j >= 0
        lvl = array.get(pastLowPrices, j)
        if (useCloseForSweep ? close < lvl : low < lvl)
            line.delete(array.get(pastLowLines, j))
            array.remove(pastLowLines, j)
            array.remove(pastLowPrices, j)
            // delete matching band lines at the same index (if they exist)
            if array.size(pastLowBandTopLines) > j
                line.delete(array.get(pastLowBandTopLines, j))
                array.remove(pastLowBandTopLines, j)
            if array.size(pastLowBandBotLines) > j
                line.delete(array.get(pastLowBandBotLines, j))
                array.remove(pastLowBandBotLines, j)
        j := j - 1
        j


// === REVERSAL CANDLE ENTRY LOGIC (zone-based) ============================


// Inputs (optional fine-tune)
var const string GRP_REV = "========== DOUBLE BOTTOM CANDLE SETTINGS =========="
useCloseForZone = input.bool(false, "Zone test uses CLOSE (else LOW/HIGH)", group=GRP_REV, tooltip="If true, close must be inside the band; else we use low for lows and high for highs.")
var const string pin_Params1 = "--- PIN BAR SETTINGS ---"
hammerFib1   = input.float(0.382, title = "Hammer fib (pin bar)", tooltip =  "Defines where the candle body must sit within its range.\nFor a hammer: fib is measured from the low upward.\nâ€¢ 0.25 = body in bottom quarter of candle (strict)\nâ€¢ 0.50 = body in lower half (looser)\nDefault 0.382 â‰ˆ lower 38% of range.", minval=0, maxval=1, group=pin_Params1)
starFib1     = input.float(0.382, title = "Shooting star fib (pin)", tooltip = "Defines where the candle body must sit within its range.\nFor a shooting star: fib is measured from the high downward.\nâ€¢ 0.25 = body in top quarter of candle (strict)\nâ€¢ 0.50 = body in upper half (looser)\nDefault 0.382 â‰ˆ upper 38% of range.", minval=0, maxval=1, group=pin_Params1)
colorMatch1  = input.bool(false, title = "Pin bar bullish or bearish?", tooltip= "Pin bars must close bullish for a Hammer and bearish for a Star", group=pin_Params1)
var const string EC_Params1 = "--- ENGULFING CANDLE SETTINGS ---"
allowancePt1 = input.float(0.2, title = "Engulf open allowance (pts)", tooltip="Tolerance for small gaps at open, it's good practice to leave a few points tolerance as gaps are prevailant", group=EC_Params1)
rejWickMax1  = input.float(0.0, title =  "Max allowable Wick/Body (0 = off)", tooltip = "Optional cleanliness filter for engulfing candles.\n0 = disabled.\nIf > 0: the wick on the rejection side must be smaller than this multiple of the candle body.\ne.g. 0.5 = wick must be < 50% of body.\nBullish: checks the TOP wick. Bearish: checks the BOTTOM wick." ,group=EC_Params1)
engulfWick1  = input.bool(false, title = "Engulf previous wick", tooltip= "If an engulfing candle occurs, to be valid it must engulf the previous wick and not just the body", group=EC_Params1)

// Guard: we only have valid zones when current swing + half-width exist
haveLowZoneCur   = not na(currentLow)  and not na(currentLowBandHalf)
haveHighZoneCur  = not na(currentHigh) and not na(currentHighBandHalf)

// ðŸŸ¢ NEW â€” Extension zone guards
haveLowZoneEx    = extLowBarsLeft  > 0 and not na(extLowPrice)  and not na(extLowBandHalf)
haveHighZoneEx   = extHighBarsLeft > 0 and not na(extHighPrice) and not na(extHighBandHalf)

// In-zone checks (choose close or extrema)
priceForLowZone  = useCloseForZone ? close : low
priceForHighZone = useCloseForZone ? close : high

inLowZoneCur  = haveLowZoneCur  and (priceForLowZone  >= (currentLow  - currentLowBandHalf))  and (priceForLowZone  <= (currentLow  + currentLowBandHalf))
inHighZoneCur = haveHighZoneCur and (priceForHighZone >= (currentHigh - currentHighBandHalf)) and (priceForHighZone <= (currentHigh + currentHighBandHalf))

inLowZoneEx   = haveLowZoneEx   and (priceForLowZone  >= (extLowPrice  - extLowBandHalf))   and (priceForLowZone  <= (extLowPrice  + extLowBandHalf))
inHighZoneEx  = haveHighZoneEx  and (priceForHighZone >= (extHighPrice - extHighBandHalf))  and (priceForHighZone <= (extHighPrice + extHighBandHalf))

inLowZone  = inLowZoneCur  or inLowZoneEx
inHighZone = inHighZoneCur or inHighZoneEx

// Candlestick patterns (evaluated on this bar)
bullPin = zen.isHammer(hammerFib1, colorMatch1)
bearPin = zen.isStar(starFib1, colorMatch1)
bullEng = zen.isBullishEC(allowancePt1, rejWickMax1, engulfWick1)
bearEng = zen.isBearishEC(allowancePt1, rejWickMax1, engulfWick1)

// Triggers: zone + correct reversal direction
longZoneTrigger  = barstate.isconfirmed and inLowZone  and (bullPin or bullEng) and isinSession  // double-bottom style
shortZoneTrigger = barstate.isconfirmed and inHighZone and (bearPin or bearEng) and isinSession // double-top style

// Plots
plotshape(longZoneTrigger,  title="Swing-Low Zone Bull Reversal",  style=shape.triangleup,   location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny, text="DB")
plotshape(shortZoneTrigger, title="Swing-High Zone Bear Reversal", style=shape.triangledown, location=location.abovebar, color=color.new(color.red,  0), size=size.tiny, text="DT")



// === ALERT CONDITIONS ===
alertcondition(highBroken, title = 'Swing High Broken', message = 'ðŸ”” Swing High Broken at {{close}}')
alertcondition(lowBroken, title = 'Swing Low Broken', message = 'ðŸ”” Swing Low Broken at {{close}}')
//updated chart.

plot(close)
